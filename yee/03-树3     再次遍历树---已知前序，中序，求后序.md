# 03-树3     再次遍历树---已知前序，中序，求后序

+++

## 题意

可以使用堆栈以非递归方式实现顺序二进制树遍历。例如，假设当遍历6节点二叉树（编号为1到6的键）时，堆栈操作为： push(1);  push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop().然后可以从该操作序列生成唯一的二叉树（如图1所示）。你的任务是给出这棵树的后序遍历序列。

![33](https://images.ptausercontent.com/30)

### 输入规格：


每个输入文件包含一个测试用例。对于每种情况，第一行包含正整数N（≤30），其是树中节点的总数（因此节点从1到N编号）。然后是2N行，每行描述一种格式的堆栈操作：“Push X”，其中X是被推入堆栈的节点的索引;或“Pop”表示从堆栈中弹出一个节点。

### 输出规格：

对于每个测试用例，在一行中打印相应树的后序遍历序列。保证存在解决方案。所有数字必须用一个空格分隔，并且在行的末尾不能有额外的空格。

### 样本输入:

```in
6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
```

### 样本输出:

```out
3 4 2 6 5 1
```



## 题解

+ 如果对[二叉树的遍历非递归实现](http://blog.csdn.net/shinanhualiu/article/details/49202189)有很好理解的话，那么这里理解起来就不是很大的难度，在输入格式中Push的过程就是二叉树前序遍历的结果，而Pop的过程及为二叉树的中序遍历的结果。如果理解了这两个操作，那么题目的意思就变成了已知二叉树的前序遍历和中序遍历求二叉树的后序遍历。由于前序遍历首先访问的是根节点，中序遍历首先访问的是左子树，而后序遍历最后才访问根节点。因此，前序遍历中第一个元素为后序遍历的最后一个元素，在中序遍历中根节点左边的为左子树的节点，右边为右子树的节点。所以需要递归的求解这个问题。 
   对于Sample的求解结果为： 

![1](https://img-blog.csdn.net/20151020171424703)

刚开始时，前序遍历的第一个元素1肯定是该二叉树的根节点，因此为postOrder的最后一个元素，在中序遍历中1前面的元素肯定为该颗二叉树的左子树,在1右边的元素肯定为该二叉树的右子树。

因此，递归求解该二叉树。 

![2](https://img-blog.csdn.net/20151020180027037)



+ **题解：**
   **前序**：1 2 3 4 5 6
   **中序**：3 2 4 1 6 5
   通过 输入的 **push** 顺序，得到**前序**遍历的数组
   通过 **push** 和 **pop** 顺序，得到 **中序**遍历的数组
   通过前序和中序的数组，可以**唯一**确定一个**后序**遍历数组。

  **后序序列**就是在每个子序列的末尾存储当前找出来的根节点，，然后进行递归直到结束

  因为后序序列就是根节点在最后存储的。**每次只存储当前的根节点**，将根节点存储完毕，也就是结束了。

  关键地方：就是在中序中找出根节点位置，以及左子序列的长度，右子序列的长度；以及当前后序序列中当前子序列的其实位置下标；还有前序序列中根节点的下标；

  **前序序列根节点的下标变化**：1、PreL+1 2、PreL+L+1
   **中序序列中子序列的起始位置**：1、InL 2、InL+L+1
   **后序序列中要存储的根节点的起始位置，也就是当前子序列的第一个位置**：1、LastL 2、LastL+L
   **左右序列的长度**：L和R

具体注释请看代码中的注释：

~~~cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;
typedef long long ll;
#define maxn 1000005
#define mod 7654321

stack<int> s;
int pre[1000],mid[1000],last[1000];

//1 2 3 4 5 6
//3 2 4 1 6 5
//通过 输入的 push 顺序，得到前序遍历的数组
//通过 push 和 pop 得到 中序遍历的数组
//通过前序和中序的数组，可以唯一确定一个后序遍历数组。

//参数：PreL为当前前序序列的起始位置，即根节点位置
//InL为当前中序序列中的左或右子树的起始位置
//LastL为后序序列中子序列起始位置的下标
//n为当前左或右子树的长度

void Solve(int PreL,int InL,int LastL,int n)
{
    if(n==0)//若没有节点直接返回
        return;
    if(n==1)//若只有一个节点，直接将其赋值给后序第一个元素
    {
        last[LastL]=pre[PreL];
        return;
    }
    int Root=pre[PreL];//存储当前子序列的根节点的值
    //LastL+n-1 就是当前序列的最后一个位置，因为根节点一定在LastL为当前子序列起始位置，
	//n为当前序列总长度，-1为当前序列最后一个位置的下标
    last[LastL+n-1]=Root;//起始位置加总长-1就是最后一个位置
    int i;

    //在当前子序列长度n中找到根节点位置
    for(i=0;i<n;i++)
    {
        if(mid[InL+i]==Root)//找到的i的位置为当前子序列中的位置
            break;
    }
    int L=i,R=n-i-1;//当前左右子序列的长度

    //递归解决左右

    /*后一个前序序列的根节点(第一个参数PreL):
	1、当前节点的下一个节点（当前左子树的根）即PreL+1
	2、以及当前节点往后推左子树的长度L(当前右子树的根)即PreL+1+L
	//中序序列开始查找的位置（第二个参数InL）
	1、当前左子树的起点往后走即InL
	2、当前右子树的起点往后走左子树的长度L即InL+1+L
	//后序序列的存储位置,当前左子树的起点位置（第三个参数postL）
	1、即当前位置postL
	2、往后走L到右子树起点即postL+L
	//第四个参数（L,R）
	存储当前左右子树的长度，最后将其值都赋值给n
	*/
    Solve(PreL+1,InL,LastL,L);
    Solve(PreL+L+1,InL+L+1,LastL+L,R);
}

int main()
{
    int n,a,j=0,k=0;

    string str;
    cin>>n;
    for(int i=0;i<2*n;i++)
    {
        cin>>str;
        if(str=="Push")
            cin>>a,s.push(a),pre[j++]=a;
        if(str=="Pop")
            mid[k++]=s.top(),s.pop();
    }

    Solve(0,0,0,n);

    for(int i=0;i<n;i++)
    {
        if(i==0)
            cout<<last[i];
        else
            cout<<" "<<last[i];
    }
    cout<<endl;
    return 0;
}
~~~



## 总结

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190306170951841-1886726002.jpg)

### 二叉树的遍历

二叉树的深度优先遍历可细分为前序遍历、中序遍历、后序遍历，这三种遍历可以用递归实现（本篇随笔主要分析递归实现），也可使用非递归实现的

 

前序遍历：根节点->左子树->右子树**（根->左->右）**

中序遍历：左子树->根节点->右子树**（左->根->右）**

后序遍历：左子树->右子树->根节点**（左->右->根）**

在进行已知两种遍历顺序求另一种遍历顺序前，先看一下不同遍历顺序对应的代码

+++

**前序遍历：**

~~~c
/* 以递归方式 前序遍历二叉树 */
void PreOrderTraverse(BiTree t, int level)
{
    if (t == NULL)
    {
        return ;
    }
    printf("data = %c level = %d\n ", t->data, level);
    PreOrderTraverse(t->lchild, level + 1);
    PreOrderTraverse(t->rchild, level + 1);
}
~~~

+++

**中序遍历:**

```c
 1 /* 以递归方式 中序遍历二叉树 */
 2 void PreOrderTraverse(BiTree t, int level)
 3 {
 4     if (t == NULL)    
 5     {
 6         return ;
 7     }
 8     PreOrderTraverse(t->lchild, level + 1);
 9     printf("data = %c level = %d\n ", t->data, level);
10     PreOrderTraverse(t->rchild, level + 1);
11 }
```

+++

**后序遍历:**

```c
 1 /* 以递归方式 后序遍历二叉树 */
 2 void PreOrderTraverse(BiTree t, int level)
 3 {
 4     if (t == NULL)    
 5     {
 6         return ;
 7     }
 8     PreOrderTraverse(t->lchild, level + 1);
 9     PreOrderTraverse(t->rchild, level + 1);
10     printf("data = %c level = %d\n ", t->data, level);
11 }
```



三种遍历方式对应的代码几乎相同，只是一条语句的位置发生了变化

```c
printf("data = %c level = %d\n ", t->data, level);
```

+++

只看文字和代码来理解遍历的过程是比较困难的，建议读者亲自去遍历，为了理清遍历的过程下面上题

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190306194614674-1602895543.png)

#### 前序遍历

前序的遍历的特点，根节点->左子树->右子树，注意看前序的遍历的代码printf语句是放在两条递归语句之前的，所以先**访问根节点G，打印G**，然后访问左子树D，此时左子树D又作为根节点，**打印D，**再访问D的左子树A

A又作为根节点，**打印A，**A没有左子树或者右子树，函数调用结束返回到D节点（此时已经打印出来的有：**GDA**）D节点的左子树已经递归完成，现在递归访问右子树F，F作为根节点，**打印F，**F有左子树访问左子树E，E作为

根节点，**打印E，**（此时已经打印出来的有：**GDAFE**），E没有左子树和右子树，函数递归结束返回F节点，F的左子树已经递归完成了，但没有右子树，所以函数递归结束，返回D节点，D节点的左子树和右子树递归全部完成，

函数递归结束返回G节点，访问G节点的右子树M，M作为根节点，**打印M，**访问M的左子树H，H作为根节点，**打印H，**（此时已经打印出来的有：**GDAFEMH**）H没有左子树和右子树，函数递归结束，返回M节点，M节点的左子树已经

递归完成，访问右子树Z，Z作为根节点，**打印Z，**Z没有左子树和右子树，函数递归结束，返回M节点，M节点的左子树右子树递归全部完成，函数递归结束，返回G节点，G节点的左右子树递归全部完成，整个二叉树的遍历就结束了

**前序遍历结果：GDAFEMHZ**



**总结一下前序遍历步骤**

第一步：**打印该节点（再三考虑还是把访问根节点这句话去掉了）**

第二步：访问左子树，返回到第一步（注意：返回到第一步的意思是将根节点的左子树作为**新的根节点**，就好比图中D是G的左子树但是D也是A节点和F节点的根节点）

第三步：访问右子树，返回到第一步

第四步：结束递归，返回到上一个节点

 **前序遍历的另一种表述：**

**（1）访问根节点**

**（2）前序遍历左子树**

**（3）前序遍历右子树**

**（在完成第2,3步的时候，也是要按照前序遍历二叉树的规则完成）**

**前序遍历结果：GDAFEMHZ**

+++

#### 中序遍历

（详细遍历过程就不再赘述了，(┬＿┬)）

中序遍历步骤:

第一步：访问该节点左子树

第二步：若该节点有左子树，则返回第一步，**否则打印该节点**

第三步：若该节点有右子树，则返回第一步，**否则结束递归并返回上一节点**

（按我自己理解的中序就是：先左到底，左到不能在左了就停下来并打印该节点，然后返回到该节点的上一节点，并打印该节点，然后再访问该节点的右子树，再左到不能再左了就停下来）

**中序遍历的另一种表述：**

**（1）中序遍历左子树**

**（2）访问根节点**

**（3）中序遍历右子树**

**（在完成第1，3步的时候，要按照中序遍历的规则来完成）**

**所以该图的中序遍历为：ADEFGHMZ**

+++

#### 后序遍历

第一步：访问左子树

第二步：若该节点有左子树，返回第一步

第三步：若该节点有右子树，返回第一步，**否则打印该节点并返回上一节点**

 **后序遍历的另一种表述：**

**（1）后序遍历左子树**

**（2）后序遍历右子树**

**（3）访问根节点**

**（在完成1,2步的时候，依然要按照后序遍历的规则来完成）**

**该图的后序遍历为：AEFDHZMG**

 （如果在纸上遍历二叉树的时候，仍然容易将顺序搞错,建议再回去看一下三种不同遍历对应的代码）

+++

***进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）***

### (1)第一种：已知前序遍历、中序遍历求后序遍历

前序遍历：ABCDEF

中序遍历：CBDAEF

在进行分析前读者需要知道不同遍历结果的特点

**1、前序遍历的第一元素是整个二叉树的根节点**

**2、中序遍历中根节点的左边的元素是左子树，根节点右边的元素是右子树**

**3、后序遍历的最后一个元素是整个二叉树的根节点**

**（如果读者不明白上述三个特点，建议再回去看一下三种不同遍历对应的代码，并在纸上写出一个简单的二叉树的三种不同的遍历结果，以加深对三种不同遍历的理解）**

用上面这些特点来分析遍历结果，

**第一步：**先看前序遍历**A**肯定是根节点![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308110049685-131632486.png)

**第二步：**确认了根节点，再来看中序遍历，中序遍历中根节点A的左边是**CBD**，右边是**EF**，所有可以确定二叉树既有左子树又有右子树

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308111832076-64554868.png)

**第三步：**先来分析左子树**CBD，**那么CBD谁来做A的左子树呢？这个时候**不能**直接用中序遍历的特点（左->根->右）得出左子树应该是这个样子

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308104123264-1263028885.png)

因为有两种情况都满足中序遍历为**CBD**

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308104526312-43746275.png)

无法直接根据中序遍历来直接得出左子树的结构，这个时候就要返回到前序遍历中去

观察前序遍历**ABCDEF，**左子树**CBD**在前序遍历中的顺序是**BCD，**意味着**B**是左子树的根节点（这么说可能不太好理解，换个说法就是B是A的左子树）,得出这个结果是因为如果一个二叉树的根节点有左子树，那么

这个左子树一定在前序遍历中一定紧跟着根节点（这个是用前序遍历的特点（根->左->右）得出的）,到这里就可以确认**B**是左子树的根节点

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308111823897-778383099.png)

**第四步：**再观察中序遍历**CBDAEF，**B元素左边是**C**右边是**D**，说明B节点既有左子树又有右子树，左右子树只有一个元素就可以直接确定了，不用再返回去观察前序遍历

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308111608228-371713643.png)

**第五步：**到这里左子树的重建就已经完成了，现在重建右子树，因为重建右子树的过程和左子树的过程一模一样，步骤就不像上面写这么细了（(┬＿┬)），观察中序遍历右子树为**EF**，再观察前序遍历**ABCDEF**中右子树

的顺序为**EF**，所以E为A的右子树，再观察中序便利中**E**只有右边有**F**，所有F为E的右子树，最后得到的二叉树是这个样子的

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308112146891-622698790.png)

所以求得的后序遍历为：**CDBFEA**

> 总结一下上述步骤： 先观察前序遍历找到根节点->观察中序遍历将根节点左边归为左子树元素，右边归为右子树元素（可能会出现只有左子树或者右子树的情况）->观察前序遍历中左\右子树几个元素的顺序，最靠前的为左\右子树的根节点->重复前面的步骤







### 第二种：已知中序遍历、后序遍历求前序遍历

（题还是上面这道）

中序遍历：CBDAEF

后序遍历为：CDBFEA

仍然是根据不同遍历方式结果的特点来重构二叉树，过程很相似这里就不详细说了，后序遍历的最后一个元素A是根节点，在中序遍历中以根节点A作为分界将元素分为左子树（**CBD**）和右子树（**EF**），再观察后序遍历中左子树的顺序是CDB

，可以判断出B是左子树的根节点（因为后序遍历是：左->右->根），再观察中序遍历，B元素左边是C右边是D，说明B节点既有左子树又有右子树，左右子树只有一个元素就可以直接确定了，不用再返回去观察后序遍历，左子树重建完成，

现在来看右子树，右子树有两个元素**EF，**观察后序遍历E在F的后面，所以E是右子树的根节点，然后看中序遍历中E只有右边一个F元素了，即F是E的右子树，此时整个二叉树重构完成

> 总结一下上述步骤：先观察后序遍历找到根节点->观察中序遍历将根节点左边归为左子树元素，右边归为右子树元素（可能会出现只有左子树或者右子树的情况）->观察后序遍历中左\右子树几个元素的顺序，最靠后的为左\右子树的根节点->重复前面的步骤





### (3)注意：已知前序遍历、后序遍历无法求出中序遍历（因为由前序后序重构出来的二叉树不止一种）

举个栗子:

![img](https://img2018.cnblogs.com/blog/1590962/201903/1590962-20190308141438270-1859838531.png)

左图这两种二叉树前序（**BEFA**）和后序（**AFEB**）一样，但对应的中序遍历结果不一样（左边的是AFEB右边的是BEFA），所以仅靠前序后序是无法重构出唯一的二叉树的！！！
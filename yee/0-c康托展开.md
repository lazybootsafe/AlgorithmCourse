# 0-c康托展开

----

## 题意

+ 官方简介：

  康托展开是一个全排列到一个自然数的双射，常用于构建哈希表的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。

+ 我的理解：

  我想要找的那个数在所有组合数(从小到大排序)中的位置。

  > 我们来看例子：
  >
  > (计算的时候 12345 序列应视为第0个序列，后面会解释为什么。)
  >
  > 拿52413举例子：
  >
  > **1.**首先看第一个数 5，不管第一位是什么数，后面都有四位数，那么这四位数全排列的方式有 4！种，而如果第一位是 1 或 2 或 3 或 4 都会比5开头的字典序要小，所以可以令1，2，3，4分别作为开头(即作为第一个数字)，这样的话就会有 4 * 4！种排法要比  52413这种排法的字典序要小。
  >
  > 那么第一个数是1，2，3，4时候的字典序的个数数完了是 4 * 4！ 种，且这些字典序都要比52413的字典序要小。
  >
  > 还有其他的排列方式比52413的字典序要小的吗？
  >
  > **2.**那么就可以固定第一位5，找下一位2，这时5已经用过了，所以从剩下的 1，2，3，4 里挑选比2小的数，一共1个，后面还剩三位，也就是3！种排列方式，那么这时候比 52413 字典序要小的又有  1 * 3！种，也就是当5在第一位，1在第二位的时候。
  >
  > **3.**再看第三位4，这时5，2都用了，所以从剩下的 1，3，4三个数中找比4小的数的个数，有两个比4小原理同上，所以这时候也可以有 2 * 2!种排列方式的字典序小于 52413
  >
  > **4.**再看第四位1，这时候会有 0 * 1！种
  >
  > **5.**再看第五位3，这时候会有0 * 0！种
  >
  > **综上所述：**
  > 对于序列： 52413 该序列展开后为： 4 * 4! + 1 * 3! + 2 * 2! + 0 * 1! + 0 * 0! ，计算结果是： 106 
  > 由于是从0开始计数的，所以最后 52413 的编号为 107
  >
  > **为什么从0开始计数？**
  > 可以这样看：我现在让你求12345的康托展开值，也就是：0\*4!+ 0\*3！+ 0\*2！+ 0\*1！+0\*0！ =  0 所以明白了吧~~
  > 康托公式最小字典序的编号就是0。



## 题解

+ 涉及到求阶乘的部分我们可以用函数来解决
+ 我们要找的那个数最好是存放在数组中，这样方便比较后续有几个数比当前元素小；并且比当前元素小的数的个数也将其存放在数组中，方便最后求和计算

~~~c
#include<stdio.h>
#define Max 100

int fun(int num)//求阶乘
{
	if(num<=1)
		return 1;
	else
		return(fun(num-1)*num);
}

int main()
{
	int num[Max];//存放比当前元素小的数的个数
	char s[Max];//存放我们要找的那个数
	int i=0,j=0,k=0,count=0,sum=0;
	char val;
	
	while(scanf("%c",&val))//获取元素,如1234
	{
		if(val=='\n')
			break;
		else
		{
			s[count]=val;
			count++;	
		}
	}
	
//求比当前元素小的数的个数
//第一个数要和剩下n-1个数比较,以此类推 
	for(i=0;i<count;i++)
	{
		for(j=i+1;j<count;j++)
		{
			if(s[i]>s[j])
				k++;
		}
		num[i]=k;//有几个数比当前元素小 
		k=0;
	}
	
//输出结果
for(j=count-1;j>=0;j--)
{
	sum+=num[k]*fun(j);
	k++;
}
printf("该数字位置为%d\n",sum+1);

return 0; 
		
} 
~~~


# 数据结构

## 9
```c
#include<stdio.h>
#include<stdlib.h>
typedef struct DLnode 
{
	int data;
	struct DLnode *prior;
	struct DLnode *next;
}DLnode, *LinkList;
 
int InitList(LinkList &L) 
{
	L = new DLnode;
	L->next = L;
	L->prior = L;
	return 1;
}
 
void TraveList(LinkList L) 
{
	DLnode *p;
	p = L->next;
	
	while (p != L) 
	{
		printf("%d ", p->data);
		p = p->next;
	}
	
	printf("\n");
}
 
int ListLength(LinkList &L) 
{
	DLnode *p;
	p = L->next;
	int length = 0;
	while (p!=L) 
	{
		length++;
		p = p->next;
	}
	
	return length;
}
 
void CreateList(LinkList &L, int &n)   //尾插法创造
{
	L = new DLnode;
	L->next = L;
	L->prior = L;
	DLnode *p;
	p = L;
	
	for (int i = 0; i < n; i++) 
	{
		printf("请输入第%d个元素的值:", i + 1);
		DLnode *s;
		s = new DLnode;
		scanf("%d", &s->data);
		p->next = s;
		s->next = L;
		s->prior = p;
		p = s;
	}
}
 
void Change(LinkList p)   //核心算法
{
	DLnode *q;
	q = p->prior;
	
	q->prior->next = p;          // p的前驱的前驱之后继为p
	p->prior = q->prior;    // p的前驱指向其前驱的前驱。
	
	q->next = p->next;    // p的前驱的后继为p的后继。 
	p->next->prior = q;   // p的后继的前驱指向原p的前驱
	
	q->prior = p;     // p与其前驱交换
	p->next = q;    // p的后继指向其原来的前驱
}
 
int main() 
{
	LinkList L;
	
	if (InitList(L)) 
	{
		printf("L初始化成功\n");
	}
	else 
	{
		printf("L初始化失败.\n");
	}
 
	printf("请输入链表元素个数:");
	int n;
	scanf("%d", &n);
	CreateList(L, n);
	TraveList(L);
	printf("链表长度:%d\n", ListLength(L));
	
	printf("请输入要交换的结点的值:");
	DLnode *s;
	s = new DLnode;
	scanf("%d", &s->data);
	DLnode *p;
	p = L->next;
	while (p != L) 
	{
		if (p->data == s->data)     //寻找节点
		{
			Change(p);
 
			break;
		}
		else 
		{
			p = p->next;
		}
	}
	
	TraveList(L);
 
	return 0;
}

```

## 10

```c
void reverse(Linklist& L)
{
	Linklist q,p=L->next;//p为图中1结点
	L -> next = NULL;//对应图中1结点后继置空
	while (p)
	{
		q = p->next;//q为p后一结点，和p同样会后移
		p->next = L->next;//p结点后继改为头结点的后继，刚开始为NULL，之后都是有结点的
		L->next = p;//头结点后继变为p结点，最先的是1结点，后面依次为 2 3 4 5
		p = q;//p结点后移
	}
}


```

## 11

```c
#include <stdio.h>
#include <stdlib.h>
#define OK 1
#define ERROR -1
#define MAXSIZE 100
#define OVEERFLOW -2
typedef int Stauts;
typedef int ElemType;
typedef struct 
{
	ElemType *elem;
	int length;
}SqList;
Stauts InitList_Sq(SqList &L)
{
	int i;
    L.elem=new ElemType[10];
    if(!L.elem) exit(OVEERFLOW);
    L.length=10;
    for(i=0;i<10;i++)
		L.elem[i]=i;
return OK;
}
Stauts ListDelete(SqList &A,int item)
{
	int i,j;
	for(j=0;j<A.length;j++)
			if(A.elem[j]==item)
			{
				for(i=j;i<A.length;i++)
					A.elem[i]=A.elem[i+1];
				A.length--;
			}
			return OK;
}
int main()
{
	int i,item;
	SqList A;
	InitList_Sq(A);
	printf("成功构建顺序表\n");
	printf("请在表中输入十个元素\n");
	for(i=0;i<A.length;i++)
	{
		A.elem[i]=i;
		scanf("%d",&A.elem[i]);
		printf("%5d",A.elem[i]);
	}
	printf("\n");
	printf("请输入要删除的数值");
	scanf("%d",&item);
	ListDelete(A,item);
	printf("操作完成后的数值为：");
	for(i=0;i<A.length;i++)
		printf("%5d",A.elem[i]);
	printf("\n");
	return 0;
}


```

## 12

```c
void MergeList(LinkList& La, LinkList& Lb, LinkList& Lc, ) 
{                      //合并链表La和Lb，合并后的新表使用头指针Lc指向
  pa=La->next;  pb=Lb->next;         //pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点
  Lc=pc=La;           //用La的头结点作为Lc的头结点 
  Lc->next=NULL;
  while(pa||pb )
{                     //只要存在一个非空表，用q指向待摘取的元素
    if(!pa)  {
q=pb;
pb=pb->next;
}                  //La表为空，用q指向pb，pb指针后移
    else if(!pb)  {
q=pa;  
pa=pa->next;
}                     //Lb表为空，用q指向pa，pa指针后移
    else if(pa->data<=pb->data)  {
q=pa;  
pa=pa->next;
}          //取较小者（包括相等）La中的元素，用q指向pa，pa指针后移
    else {
q=pb;  
pb=pb->next;
}//取较小者Lb中的元素，用q指向pb，pb指针后移
     q->next = Lc->next; 
  Lc->next = q;   
//将q指向的结点插在Lc 表的表头结点之后
    }
    delete Lb;             //释放Lb的头结点
}


```

## 13 
c++

```
#include <iostream>
using namespace std;
 
typedef struct LNode
{
	int data;
	LNode *next;
}LNode,*LinkList;
 
//创建链表
int CreateList(LinkList &L,int n)
{
	LNode *p,*r;int i;
	L=new LNode;
	L->next=NULL;
	r=L;
	for(i=0;i<n;i++)
	{
		p=new LNode;
		cin>>p->data;
		p->next=NULL;r->next=p;
		r=p;
	}
	return 0;
}
 
 
 
//输出链表
void display(LinkList L)
{
	LNode *p;
	p=L->next;
	cout<<"(";
	while(p)
	{cout<<p->data<<" ";
	p=p->next;}
	cout<<")"<<endl;
}
 
//拆分
int SplitList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{
    LNode *pa;LNode *pb;LNode *pc;
    pa=LA->next;pb=LB;pc=LC;
    while(pa)
    {
       if(pa->data<0)
        {
            pb->next=pa;
            pa=pa->next;
            pb=pb->next;
            pb->next=NULL;
        }
        else
        {
            pc->next=pa;
            pa=pa->next;
            pc=pc->next;
            pc->next=NULL;
        }
 
    }
}
 
 
 
int main()
{
	LinkList LA;LinkList LB;LinkList LC;int n;;
 
 
	cout<<"请输入需要创建单链表A的长度："<<endl;
	cin>>n;
	cout<<"请依次输入需要存入的数据(尾插法&&非零)："<<endl;
	CreateList (LA,n);
 
	cout<<"单链表A为：";
	display(LA);
 
	LB=new LNode;LC=new LNode;
	LB->next=NULL;LC->next=NULL;
 
	SplitList_L(LA,LB,LC);
	cout<<"分解后单链表B为：";
	display(LB);
	cout<<"分解后单链表C为：";
	display(LC);
 
	return 0;
}
 
```


## 14

```c
#include<stdio.h>
#include<malloc.h> 
typedef  struct list {  
    int data;  
    struct list * next;  //下一个节点地址   
}list;  
//第一条链表 
struct list * L=NULL;//头
struct list * head=NULL;//首
struct list * p=NULL;  
//第二条链表
struct list * L1=NULL;//头
struct list * head1=NULL;//首
struct list * p1=NULL; 
//代理链表
struct list * L2=NULL;//头
struct list * q=NULL;//L2备用地址 
struct list * q1=NULL;//备用地址 
int main()
{
	int i=0,length;
	printf("请输入链表的长度\n");
	scanf("%d",&length); 
	head=(struct list *)malloc(sizeof(struct  list)); 
	L=head;
	printf("请依次输入链表的内容\n");
	for(i;i<length;i++){
		p = (struct list *)malloc(sizeof(struct  list));
        scanf("%d",&p->data);
        p->next=NULL;
        head->next=p;
        head=p;
    }
    int i1=0,length1;
	printf("请输入链表的长度\n");
	scanf("%d",&length1);
	 
	head1=(struct list *)malloc(sizeof(struct  list)); 
	L1=head1;
	printf("请依次输入链表的内容\n");
	for(i1;i1<length1;i1++){
		p1= (struct list *)malloc(sizeof(struct  list));
        scanf("%d",&p1->data);
        p1->next=NULL;
        head1->next=p1;
        head1=p1;
    }
    L2=(struct list *)malloc(sizeof(struct  list));
	q=L2;//备用合并链表起始地址 
	p=L->next;
    p1=L1->next;
	while(p&&p1){	
	  if(p->data<p1->data){
     	L2->next=p;
		L2=p;
		p=p->next;
	}else if(p->data==p1->data){
		L2->next=p;
		L2=p;
		p=p->next;
		q1=p1->next;//备用相同元素的下一个地址指向 
		free(p1);
		p1=q1;
		
	}else if(p->data>p1->data){
		L2->next=p1;
		L2=p1;
		p1=p1->next;
	}		
	}
   L2->next=p?p:p1;
   free(L1);
   printf("合并后链表的内容\n");
    p=q->next;
    while(p){
	printf("%d ",p->data);
	p=p->next;
	}
	
}
```


## 15

```c
#include<stdio.h>
#include<stdlib.h>
#define OK 1
#define ERROR -1
typedef int Status;
typedef int ElemType;
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;

//初始化
Status InitList(LinkList &L){
    L = new LNode;
    L->next = NULL;
    return OK;
}

//创建单链表前插法
void CreateList(LinkList &L,int m){
    LinkList t;
    printf("请输入数值：\n");
    for(int p = 0 ; p < m ; p++){
        t = new LNode;
        scanf("%d",&t->data);
        t->next = L->next;
        L->next = t;
    }
}

//显示链表
void ShowList(LinkList L)
{
	LinkList p;
	p = L->next;
	while (p)
	{
		printf("%4d", p->data);
		p = p->next;
	}
	printf("\n");
}

//求最大值
int GetMax(LinkList L){
	LNode *pmax,*p;
	if(L->next == NULL)
		return NULL;
	pmax = L->next;//假定第一个结点中数据具有最大值
	p = L->next->next;
	while (p){//如果下一个结点存在
		if(p->data > pmax->data)
			pmax = p; //如果p的值大于pmax的值，则重新赋值
		p = p->next;//遍历链表
	}
	return pmax->data;
}

//主函数实现
int main(){
	int n;
	LinkList L;
	InitList(L);//初始化
	printf("请输入链表的长度：");
	scanf("%d",&n);
	CreateList(L,n);
	printf("当前链表：\n");
	ShowList(L);
	int a = GetMax(L);
	printf("最大结点：%d\n",a);
	return 0;
}

```

##
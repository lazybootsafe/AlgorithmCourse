# LeetCode 455  |  分发饼干

+++

## 原题地址

<https://leetcode-cn.com/problems/assign-cookies/>



## 题意

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

示例 1:

~~~
输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
~~~



## 题解

其实就是两个指针遍历小孩和饼干两个数组，当小孩数组指针指向的元素小于等于饼干数组指针指向的元素时，计数cnt++，表示这个饼干可以发给对应的小孩，发放后两个指针都++；当小孩数组指针指向的元素大于饼干数组指针指向的元素时，表示饼干太小，所以饼干数组指针向后++，当其中一个数组被遍历后结束循环。本来以为这就结束了，没想到运行时给出的数组并不是排好序的，这就导致上面的逻辑错了，所以循环前先对两个数组排序。

~~~c
int comp(const void*a,const void*b)
{
    return *(int*)a-*(int*)b;
}
int findContentChildren(int* g, int gSize, int* s, int sSize){
    int cnt=0,i=0,j=0;
    qsort(g,gSize,sizeof(int),comp);
    qsort(s,sSize,sizeof(int),comp);
    while(i<gSize&&j<sSize)
    {
        if(s[j]>=g[i])
        {
            cnt++;
            i++;
            j++;
        }
        else
        {
            j++;
        }
    }
    return cnt;
}
~~~


# LeetCode 1029  | 两地调度

+++

## 原题地址

<https://leetcode-cn.com/problems/two-city-scheduling/>



## 题意

公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。

 

示例：

~~~
输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。


提示：

1 <= costs.length <= 100
costs.length 为偶数
1 <= costs[i][0], costs[i][1] <= 1000
~~~



## 题解

对于每一个人 都有两种选择:
1.去A城
2.去B城
选择去A城 则费用+costs[i][0] 去A城次数+1
选择去B城 则费用+costs[i][1] 去B城次数+1
且去A城和B城的次数都有限制 必须等于n/2
综上， 这道题可以用01背包问题的处理方式来解决：
把人作为物品 ，把去A城或去B城的次数作为背包的容量， 把去A城或去B城的费用当成物品的价值 ，而“物品”的重量统一为1 ，无论去A城还是去B城 ，对应的次数均+1，
那么 ，可以非常流畅的写出状态转移方程：
设dp[i][j]表示i个人飞往A市的次数为j的最低费用
则有：dp[i][j]=min(dp[i-1][j-1]+costs[i][0],dp[i-1][j]+costs[i][1]);  //前者飞往A市 后者飞往B市
但必须注意： 这道题与以往的常规的01背包问题不一样
再来回顾一下， 常规的01背包问题：
有若干个物品，它们有各自的体积和价值，现有给定容量的背包，求让背包里装入的物品具有最大的价值总和
注意：在常规的的01背包问题中 ，并没有要求背包必须恰好装满
尽管最后返回的结果是dp[N][W] ，但实际中可能存在没有装满的情况 ，这种情况从何而来？
不妨从初始条件开始推理：
01背包问题的初始条件为
dp[0][0]
dp[i][0]   //i>=1&&i<=N
dp[0][j]  //j>=1&&j<=W
分别分析一下这些初始条件各代表什么意思：
dp[0][0] 当前物品数为零 当前背包容量为零 这种情况下产生的最大价值自然为零 故dp[0][0]=0
dp[i][0] 当前物品数为i 当前背包容量为零 由于容量为零 放不进物品 产生的最大价值为零 故dp[i][0]=0
dp[0][j] 当前物品数为0 当前背包容量为j 由于物品数为零 产生的最大价值为零 故dp[0][j]=0
后续的一切状态均由这三种状态转移而来 下面分析是何种原因导致了背包未满的情况

分析论证：
对于dp[i][j]的两个状态量 根据状态转移方程dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
可以看出 无论放不放物品 i的值必定会改变 而只有放物品 才能改变j的值
假设从某一状态dp[i'][j']到达最终状态dp[N][W]
把容量W分成两部分来看 W=j'+W-j' 只要j'和W-j'都是装满的 则W必为装满的状态
从dp[i'][j']到dp[N][W] 状态j的值变化了W-j' 即状态j的值改变了 故而这W-j'必定是靠填充物品得来的 即对于“W-j'”这一部分的容量来说 是满的
故而 只要容量“j'”是装满的 则dp[N][W]必定是装满的
而对于dp[i'][j']可以继续拆解为两部分 直至拆解到三种初始状态之一
而对于dp[0][0] dp[i][0]而言 由于其初始背包容量为零 物品数大于等于零 意味着其初始状态就是一种装满状态
而对于dp[0][j]而言 由于其初始背包容量大于零 物品数等于零 意味着其初始状态就是一种没有装满的情况
初始的背包容量并没有靠物品去填充 故而结合前面的分析论证 可以得出：
一切由dp[0][0] dp[i][0]推导的状态dp[i'][j'] 其背包真实容量必定等于j'
一切由dp[0][j]推导的状态dp[i'][j'] 其背包真实容量必定小于j'
进而得出一般性的结论：
由dp[0][0] dp[i][0]为初始状态的状态 其背包必定装满 由dp[0][j]为初始状态的状态 其背包必定装不满

故而 正因为有dp[0][j]的存在 才导致dp[N][W]可能装不满(当dp[N][W]是由dp[0][j]推导得出时)

然而 对于常规01背包问题 是不要求背包一定要装满
故无论是dp[0][0] dp[i][0] 还是dp[0][j] 均视为有效状态并且可以根据其表示的实际意义得出它们的数值
而对于这道题 如果用动态规划的方法来解 则本题是一个要求恰好装满的01背包问题

回到本题
本题要求每个城市都有N个人抵达 即A城 B城必须去各N个人 一个不能多 一个也不能少 所以归结到要求恰好装满的01背包问题

既然如此 如何求解这个恰好装满的01背包问题呢？

要求恰好装满的01背包问题与常规01背包问题只有一个区别：
最终状态dp[N][W]必须由dp[0][0]||dp[i][0]转移而成 而不能由dp[0][j]转移而成
亦即 所有状态dp[i][j]必须由dp[0][0]||dp[i][0]转移而成 而不能由dp[0][j]转移而成

而如何做到这点呢？其实并不难 只要将dp[0][j]设为无效状态 使dp[0][j]不能再被选择
所以可将dp[0][j]的数值极端化 并且是与所求最优解性质相反的极端化
例如 常规01背包是求最大值 dp[0][0]=0 dp[i][0]=0
为使dp[0][j]不能再被选择 可将dp[0][j]=-INF 则在max()的判断语句中 dp[0][j]必不会被选择
本题是求最小值 为使dp[0][j]不能再被选择 可将dp[0][j]=INF 则在min()的判断语句中 dp[0][j]必不会被选择

故而 对于恰好装满的01背包问题 与常规01背包问题相比 只要改变一个地方：
将dp[0][j]的数值极端化 并且是与所求最优解性质相反的极端化

而对于本题的dp[0][0] dp[i][0] 由于其是有效状态 则必须探讨其实际意义：
dp[0][0]表示有0个人 必须有0个人去往A地 自然 dp[0][0]=0
dp[i][0]表示有i个人 必须有0个人去往A地 这i个人没有一个去A地 故这i个人全部去往B地
故：
for(i=1;i<=n;i++)
dp[i][0]=dp[i-1][0]+costs[i-1][1];

故而可以轻松写出核心代码：

~~~
long long dp[n+1][n/2+1];
dp[0][0]=0;
for(i=1;i<=n;i++)
dp[i][0]=dp[i-1][0]+costs[i-1][1];
int inf=pow(10,9)+7;
for(j=1;j<=n/2;j++)
dp[0][j]=inf;
for(i=1;i<=n;i++)
for(j=1;j<=n/2;j++)
dp[i][j]=min(dp[i-1][j-1]+costs[i-1][0],dp[i-1][j]+costs[i-1][1]);
return dp[n][n/2];
~~~

优化成一维数组：

~~~
long long dp[n/2+1];
dp[0]=0;
int inf=pow(10,9)+7;
for(j=1;j<=n/2;j++)
dp[j]=inf;
for(i=1;i<=n;i++)
{for(j=n/2;j>=1;j--)
dp[j]=min(dp[j-1]+costs[i-1][0],dp[j]+costs[i-1][1]);
dp[0]+=costs[i-1][1];}
return dp[n/2];
~~~

完整代码如下：

~~~c
int min(int a,int b){
if(a<b) return a;
return b;}
int twoCitySchedCost(int** costs, int costsSize, int* costsColSize){
int i,j,k;
int n=costsSize;
long long dp[n/2+1];
dp[0]=0;
int inf=pow(10,9)+7;
for(j=1;j<=n/2;j++)
dp[j]=inf;
for(i=1;i<=n;i++)
{for(j=n/2;j>=1;j--)
dp[j]=min(dp[j-1]+costs[i-1][0],dp[j]+costs[i-1][1]);
dp[0]+=costs[i-1][1];}
return dp[n/2];
}
~~~


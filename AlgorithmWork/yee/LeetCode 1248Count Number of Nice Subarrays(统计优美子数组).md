# LeetCode 1248|Count Number of Nice Subarrays(统计优美子数组)

## 原题地址

<https://leetcode.com/problems/count-number-of-nice-subarrays/>

## 题意

给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。

我们来看样例：

```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
```

## 题解

    首先看一个很简单的样例：
    
    [2,2,2,1,2,2,1,2,2], k = 2 答案为12
    那么答案是怎么来的呢？
    
    首先统计每个奇数前后各有多少个偶数：
    
    在这个样例中有两个奇数，[1,1]
    用两个数组，分别储存每个奇数前面有多少个偶数，以及后面有多少个偶数
    每个奇数前面的偶数数量[3,2]
    每个奇数后面的偶数数量[2,2]
    注意：统计前面偶数数量的时候，到前面一个奇数为止，例如第二个1,前面（到第一个1）就两个偶数而不是5个，统计后面的偶数也是同样
    
    然后统计每段k个相邻的奇数可以有多少种优美子数组
    
    k = 2 正好有两个奇数，而第一个奇数前面有三个偶数，说明优美子数组的最开始可以有0,1,2,3个偶数；第二个奇数后面有2个偶数，说明优美子数组的结尾可以有0,1,2个偶数，则结果就是(3+1)*(2+1)=12
    
    到这里这个题的基本思路就结束了，然后再看一个长一点的示例：
    
    [2,1,2,2,1,2,2,2,1,2,2,2,2,1,2,2,2,1,2,2,1,2,2,2], k = 3
    每个奇数前面的偶数数量[1,2,3,4,3,2]
    每个奇数后面的偶数数量[2,3,4,3,2,3]
    k = 3则:
    
        第一段3个相邻奇数为第1-3个奇数，然后这一部分的结果为(1+1)(4+1)=10
        第二段3个相邻奇数为第2-4个奇数，然后这一部分的结果为(2+1)(3+1)=12
        第二段3个相邻奇数为第3-5个奇数，然后这一部分的结果为(3+1)(2+1)=12
        第二段3个相邻奇数为第4-6个奇数，然后这一部分的结果为(4+1)(3+1)=20
        最终答案10+12+12+20=54

代码如下：

~~~C
int numberOfSubarrays(int* nums, int numsSize, int k){
    int *front  = (int*)calloc(numsSize, sizeof(int));
    int *behind = (int*)calloc(numsSize, sizeof(int));
    int f = 0, b = 0;
    int lf = 0, lb = 0;
    int ans = 0;
    for(int i = 0; i < numsSize; ++i) {
        if(nums[i] % 2 == 0) {
            ++f;
        }
        else {
            front[lf++] = f;
            f = 0;
        }
        if(nums[numsSize - i - 1] % 2 == 0) {
            ++b;
        }
        else {
            behind[lb++] = b;
            b = 0;
        }
    }
    for(int i = 0, j = lb - i - k; i < lf && j >= 0; ++i, --j) {
        ans += (front[i] + 1) * (behind[j] + 1);
    }
    return ans;
}
~~~

代码中统计后面偶数的个数的数组顺序为反向，这样统计比较容易
/*
	翻译程序的第一步：

	对程序作预处理之前，编译器会进行几次翻译处理。

	1.字符映射：编译器首先把源代码中的字符映射到源字符集（该过程处理多字节字符和使C外观更加国际化的三元字符）

	2.转换物理行：编译器查找反斜线后紧跟换行符的实例并删除这些实例。也就是说，将类似下面的2个物理行：
					printf("That's wond\
					erful!\n");
					转换成一个逻辑行：
					printf("That's wonderful!\n");
					注意：在这种场合下，“换行符”代表按下回车键在源代码文件中新起一行所产生的字符，而不是符号\n代表的字符。
					因为预处理表达式的长度为一逻辑行，所以这个功能为预处理做了准备工作。而一个逻辑行可能会比一个物理行多。

	3.处理文本：接下来，编译器将文本划分成预处理的语言符号序列和空白字符及注释序列。注意：编译器用一个空格字符代替每一个注释。因此，像下面语句：
					int/*This isn't a space* / fox;
					将变成：
					int fox;
					C实现可能还会选用单个空格代替每一个空白字符序列（不包括换行符）。
					最后进入预处理器阶段。预处理器寻找可能存在的预处理指令。这些指令由一开始处的#符号标识。*/

#include <stdio.h>							//#标识一条预处理指令


/*ANSI标准允许#符号之前有空格或制表符			也允许#符号和指令之间有空格或制表符。*/
		#		    define			TWO				2		/*如果需要，可以使用注释*/


/*预处理指令从#开始，到其后第一个换行符为止。即处理的长度仅限于一行代码。
但是，刚提过，在预处理前系统会删除反斜线和换行符的组合。
因此可以把指令扩展到几个物理行，由这些物理行组成单个逻辑行。*/
#define OW "Consistency is the lase refuge of the unimagina\
tive. - Oscar Wilde"						//反斜线把这个定义延续到下一行（替换列表的后半部分在另起一行后，必须左对齐，否则会将行开头和tive之间的部分也视作替换列表的一部分）
#define FOUR TWO*TWO
#define PX printf("X is %d.\n",x)
#define FMT "X is %d.\n"

/*每个#define行（即逻辑行）由三部分组成：
		第一部分为指令#define本身
		第二部分为所选择的缩略语，这些缩略语称为宏。（像本例中的这些宏用来代替值，它们被称为类对象宏（object-like macro,C还有类函数宏，后面讨论）。
		宏的名字中不允许有空格，且必须遵循C变量的命名规则：只能使用数字、字母、下划线，首字符不能是数字。
		第三部分（#define行的其余部分）称为替换列表（replacement list）或主体（body）：*/

#define				PX				printf("X is %d.\n",x)
//预处理器指令      宏              替换列表（主体）

//预处理器在程序中发现了宏的实例后，总会用实体代替该宏（有一种例外，以后说明）。从宏变成最终的替换文本的过程称为宏展开（macro expansion）。（当然，可以使用标准的C注释在#define行中进行注释，真如前面提到的，在预处理器处理之前，每个注释会被一个空格所代替。）

int main(void)
{
	int x = TWO;

	PX;										//新的用法：以前只是用宏代替常量。调试该句知道，宏可以表示字符串，甚至可以表示整个C表达式。但要注意，PX是个常量字符串，它只打印名为x的变量。
	x = FOUR;								/*新情况： 进行宏展开，
											          语句变为x=TWO*TWO;
											          再变成x=2*2;然后，
											          宏展开的过程结束。
											 注意：1.因为C编译器在编译器常量表达式求值，所以实际相乘过程发生在编译阶段，而不是预处理器阶段。预处理器只进行简单的文字替换操作。
											       2.宏定义中可以嵌套其他宏（有些编译器不支持）
											（不是直接用4代替FOUR，区分开）*/
	printf(FMT, x);							//宏展开，用相应字符串替换了FMT（也可用类型限定词const修饰的字符串常量）
	printf("%s\n", OW);						//用相应字符串替换OW。双引号标志使替代字符串成为字符串常量。编译器把该字符串存储在以空字符结束的数组里。

	//一般而言，预处理器发现程序中的宏后，会用它的等价替换文本代替宏。如果该字符串中包括宏，则继续替换这些宏。
	//例外情况是双引号中的宏。因此，下面的语句：
	printf("TWO: OW\n");				
	//将打印字符串TWO： OW

	getchar();
	return 0;
}

#define END "end"						   /*预处理指令可以出现在源文件的任何地方。
											 指令定义的作用域从定义的位置开始到文件的结尾。
											 #define指令可以大量定义符号常量或明显常量，但它的应用范围远不止此*/

/*
	符号常量的使用价值：
		记忆值的能力，易更改性，可移植性等。*/


/*
	const关键字提供了创建符号常量的更灵活方法。使用const可以创建全局常量、局部常量、数字常量、数组常量、和结构常量。
	另一方面，宏常量可以用来指定标准数组的大小并作为const值的初始化值：*/
#define LIMIT 20
const int LIM = 50;

static int data1[LIMIT];				//合法
//static int dataw[LIM];				//无效

const int LIM2 = 2 *			LIMIT;  //合法
//const int LIM = 2 *			LIM;	//无效